Vert.x:
.......

What is Vertx?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.


Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.


 How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                    compilers
                        |
                      .class
                        |
                       jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

non blocking io and async :
...........................

IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.


The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.


IO SYSTEM CALL Api:

Java - io api
 |
jvm
jni -  io api - java native interface api , which low level api to os
|
os
|
system calls - os io api
|
device driver - io api
|
----------device


READ-----------------|windows---read


Socket :

 It is entry and exit point of device io world.
Socket isloates  kernal space and device drivers


Blocking code in java:
.....................

blocking network socket app.

package com.ibm.blocking;


import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class BlockingEco {
    public static void main(String[] args) throws Throwable {
        //this api interally communicates network interface card
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(3000));
        System.out.println("Blocking Socket : listening for new Request");
        while (true) {   // <1>
            Socket socket = server.accept();
            //each incomming request(socket request) allocate in a separate thread
            new Thread(clientHandler(socket)).start();
        }
    }

    private static Runnable clientHandler(Socket socket) {
        return () -> {

            try (
                    BufferedReader reader = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                    PrintWriter writer = new PrintWriter(
                            new OutputStreamWriter(socket.getOutputStream()))) {
                String line = "";
                while (!"/quit".equals(line)) {
                    line = reader.readLine();      // <2>
                    System.out.println("~ " + line);
                    writer.write(line + "\n");  // <3>
                    writer.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
    }

}


Why not blocking?

Blocking APIs waste resources, increase costs


The main problem with the code above ,is that it allocates a new thread for each incoming connection
and threads are anything but cheap resources. 

A thread needs memory, and the more threads you have, the more you put pressure on the operating system kernel scheduler, as it needs to give CPU time to the thread

 Input/output operations such as readLine and write may block the thread, meaning that it is being parked by the operating system. This happens for two reasons:

A read operation may be waiting for data to arrive from the network.
A write operation may have to wait for buffers to be drained if they are full from a previous write operation

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Asynchronous programming with non-blocking I/O:

Instead of waiting for I/O operations to complete, we can shift to non-blocking I/O.

You may have already sampled this with the select function in C.


The idea behind non-blocking I/O is to request a (blocking) operation, and move on to doing other tasks until the operation is ready.

For example a non-blocking read may ask for up to 256 bytes over a network socket, and the execution thread does other things (like dealing with another connection) until data has been put into the buffers, ready for consumption in memory.

In this model, many concurrent connections can be multiplexed on a single thread, as network latency typically exceeds the CPU time it takes to read incoming bytes.


Low Level System calls for non blocking:

I/O multiplexing
I/O multiplexing is the the ability to perform I/O operations on multiple file descriptors. Input operations like read, accept and calls for receiving messages block when there is no incoming data. So, if an input call is made and it blocks, we may miss data from other file descriptors. To circumvent this, I/O multiplexing calls, viz., select, poll, and the epoll API calls, are provided. A process blocks on an I/O multiplexing call. When this call returns, the process is provided a set of file descriptors which are ready for I/O. And, the process can do I/O on these file descriptors before it goes for the next iteration of the I/O multiplexing call

1.select
2.poll
3.  aio_read - asynchronous read

1.select:
select is a system call and application programming interface (API) in Unix-like and POSIX-compliant operating systems for examining the status of file descriptors of open input/output channels.

select() allows a program to monitor multiple file descriptors,
       waiting until one or more of the file descriptors become "ready" for
       some class of I/O operation (e.g., input possible).  A file
       descriptor is considered ready if it is possible to perform a
       corresponding I/O operation (e.g., read(2), or a sufficiently small
       write(2)) without blocking.


       select() can monitor only file descriptors numbers that are less than
       FD_SETSIZE; poll and epoll  do not have this limitation. 

2.poll:
poll is a POSIX system call to wait for one or more file descriptors to become ready for use
poll, ppoll - wait for some event on a file descriptor.

Select has lot of drawbacks.

Poll is fundamentally is event driven.
Poll listens for file descriptor events.


https://man7.org/linux/man-pages/man2/poll.2.html

Other advanced implementations:

1.kqueue, 
2.epoll, 
3./dev/poll
4.I/O completion ports



epoll - I/O event notification facility

-event poll api
-monitors multiple file descriptors
-specific to linux

Kernel queue (kqueue)
If you are programming with asynchronous (non-blocking) frameworks, then most likely this framework is using kernel polling APIs under the hood. Using an infinite loop, kernel polling APIs check for events and notify the caller when an event has occurred. 
 For example when an HTTP request is fired, in each iteration of the loop a check is done to see if data already has returned from the server. 

Linux uses epoll
BSD and OSX use kqueue
Windows uses IOCP
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Event Loop:
..........
events are picked up solely from epoll and ‘dispatched’ on the same thread within each loop iteration to our request handler ‘app’.

java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.


NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}

Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.


NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


///////////////////////////////////////////////////////////////////////////////////////////////////////

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vertx uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Simple Vertx Event loop simulation:
package com.ibm.eventloop;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.function.Consumer;

public final class EventLoop {

    //event queue
    private final ConcurrentLinkedDeque<Event> events = new ConcurrentLinkedDeque<>();
    //handler ; key-value binding
    private final ConcurrentHashMap<String, Consumer<Object>> handlers = new ConcurrentHashMap<>();

    public static void main(String[] args) {
        EventLoop eventLoop = new EventLoop();

        new Thread(() -> {
            for (int n = 0; n < 6; n++) {
                delay(1000);
                //event dispatch
                eventLoop.dispatch(new EventLoop.Event("tick", n));
            }
            eventLoop.dispatch(new EventLoop.Event("stop", null));
        }).start();

        new Thread(() -> {
            delay(2500);
            eventLoop.dispatch(new EventLoop.Event("hello", "beautiful world" + Thread.currentThread().getName()));
            delay(800);
            eventLoop.dispatch(new EventLoop.Event("hello", "beautiful universe"));
        }).start();

        eventLoop.dispatch(new EventLoop.Event("hello", "world!"));
        eventLoop.dispatch(new EventLoop.Event("foo", "bar"));

        //event registration with callbacks ; queue binding
        eventLoop
                .on("hello", s -> System.out.println("hello " + s))
                .on("tick", n -> System.out.println("tick #" + n))
                .on("stop", v -> eventLoop.stop())
                .run();

        System.out.println("Bye!");
    }

    private static void delay(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public EventLoop on(String key, Consumer<Object> handler) {
        handlers.put(key, handler);
        return this;
    }

    public void dispatch(Event event) {
        events.add(event);
    }

    public void run() {
        while (!(events.isEmpty() && Thread.interrupted())) {
            if (!events.isEmpty()) {
                Event event = events.pop();
                if (handlers.containsKey(event.key)) {
                    handlers.get(event.key).accept(event.data);
                } else {
                    System.err.println("No handler for key " + event.key);
                }
            }
        }
    }

    public void stop() {
        Thread.currentThread().interrupt();
    }

    public static final class Event {
        private final String key;
        private final Object data;

        public Event(String key, Object data) {
            this.key = key;
            this.data = data;
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////

Lets enter into vertx app; how to build non blocking and async apps:
....................................................................

Lets code:

-Vertx Project setup

-Maven Project
-Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project

Vetx Distribution:

-maven
-zip

download zip and extract and set path 
C:\softwares\vert.x-3.9.2-full\vertx\bin



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
How to run vertx application?

We have many ways:

1.via maven.

running:
./mvnw clean compile exec:java
or
mvn clean compile exec:java

2.fat jar running:

you can pack vertx application into fat jar and you can


1.Create fat jar

mvnw clean package

2. Running

java -jar target/vertx-apps-1.0.0-SNAPSHOT-fat.jar


3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java



3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
HTTP server started on port 8888
Succeeded in deploying verticle


4.via coding - to be discussed later

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vertx apps:

vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............

vertx-core:
..........
........................................................................................................

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler).

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles



How to create vertx instance?
package com.ibm.vertx.core;

import io.vertx.core.Vertx;

public class VertxInstanceCreation {
  public static void main(String[] args) {
    //create vertx instance
    Vertx vertxInstance = Vertx.vertx();
    System.out.println(vertxInstance.getClass().getName());

  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.
  -It is based on design pattern called "Actor-like Model"
  -Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment

How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}


package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {

  //life cycle methods
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("init");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop");
  }
}

How to deploy(run) the above code?

if you want to run any code, you need entry point-main method.

vertx provides entry method-main method called "Launcher"

Launcher is a program, which has built in main method.

In general , lanucher is "vertx" runtime command only


in pom.xml we have lanucher configuration.

  <properties>
    <main.verticle>com.ibm.vertx.core.HelloWorldVerticle</main.verticle>
  </properties>


   <manifestEntries>
           <Main-Class>io.vertx.core.Launcher</Main-Class>
           <Main-Verticle>${main.verticle}</Main-Verticle>
    </manifestEntries>

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Verticle Deployment via coding:
...............................

In vertx , verticle deployment itself is async, which is non blocking.

Runner class ; it is utility class provided by vertx for deployment, it is very usefull for dev.


How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}


package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {

  //life cycle methods
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("init");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop");
  }
}

How to deploy(run) the above code?

if you want to run any code, you need entry point-main method.

vertx provides entry method-main method called "Launcher"

Launcher is a program, which has built in main method.

In general , lanucher is "vertx" runtime command only


in pom.xml we have lanucher configuration.

  <properties>
    <main.verticle>com.ibm.vertx.core.HelloWorldVerticle</main.verticle>
  </properties>


   <manifestEntries>
           <Main-Class>io.vertx.core.Launcher</Main-Class>
           <Main-Verticle>${main.verticle}</Main-Verticle>
    </manifestEntries>

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

In vertx , verticle deployment itself is async, which is non blocking.

package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;

public class GreeterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    //Get Vertx(container)
    Vertx vertxIns = Vertx.vertx();
    //you have method called deploy
    //way -1 - create verticle object new
    vertxIns.deployVerticle(new GreeterVerticle());
    //way -2 : passing class name
    vertxIns.deployVerticle(GreeterVerticle.class.getName());
    //way 3; string class name
    vertxIns.deployVerticle("com.ibm.vertx.core.GreeterVerticle");
    
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter start");
  }
}

Vertx team has provided a utility class for verticle deployment?
   Vertx vertxIns = Vertx.vertx(); - syntax not necessary.


******************************************************************************************

package com.ibm.vertx.core.verticles;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;


public class MainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(MainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Main Verticle");
    vertx.deployVerticle(UserVerticle.class.getName());
  }
}
	
package com.ibm.vertx.core.verticles;

import io.vertx.core.AbstractVerticle;

public class UserVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("User Verticle");
  }
}

Vert x and Event loop:

Vertx process events comming from kernal space , via event loop, still it is while loop but that loop bound to a thread , that thread is called event loop thread.

Every verticle by default is bound to a thread Event loop thread.

Verticle can handle events and process them.

How many event loops are there in vertx?

In node js , only one event loop.

In vertx per cpu core 2 event loops.

eg , if i have 12 cores - 24 event loop.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.ibm.vertx.future;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

class FutureVerticle extends AbstractVerticle {

  //empty future
  public Future<Void> getEmptyFuture() {
    //future object creation
    Future<Void> future = Future.future();
    //encapuslate data , no data here
    future.complete();
    return future;
  }

  public Future<String> getSuccessFuture() {
    //future object creation
    Future<String> future = Future.future();
    //encapuslate data , no data here
    future.complete("Hello ? How are you ?");
    return future;
  }

  public Future<String> getFailureFuture() {
    //future object creation
    Future<String> future = Future.future();
    //encapuslate data , no data here
    future.fail("SOmething went wrong");
    return future;
  }

  //some logic
  public Future<String> someLogic() {
    boolean isValid = false;
    //future object creation
    Future<String> future = Future.future();
    if (isValid) {
      //encapuslate data , no data here
      future.complete("This is valid");
    } else {
      future.fail(new RuntimeException("This is invalid"));
    }
    return future;
  }

  @Override
  public void start() throws Exception {
    super.start();
    //registration
    if (getEmptyFuture().succeeded()) {
      System.out.println("Future is success");
    }
    //register with sethandler ; annmous class
    getSuccessFuture().setHandler(new Handler<AsyncResult<String>>() {
      @Override
      public void handle(AsyncResult<String> asyncResult) {
        //grab result
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result());
        }
      }
    });
    getSuccessFuture().setHandler(asyncResult -> {
      //grab result
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      }
    });
    getSuccessFuture().onComplete(asyncResult -> {
      //grab result
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      }
    });
    getSuccessFuture().onSuccess(response -> {
      System.out.println(response);
    });
    getSuccessFuture().onSuccess(System.out::println);
    ///////////////////handle failures
    getFailureFuture().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
    });
    getFailureFuture().onFailure(System.out::println);
    //////////////////////////////////////////////////////////////////////////////////////////
    someLogic().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    someLogic()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

  }
}


public class FututureMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FututureMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FutureVerticle());
  }
}


Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling asyn results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.

Promises must be converted into Future before processing.


package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  //how to send success results : can be any type
  public Promise<String> getSuccessPromise() {
    //create Future object
    Promise<String> promise = Promise.promise();
    //empty response injection
    promise.complete("Hello I am Promise result!!");
    return promise;
  }

  public Future<String> getSuccessPromise1() {
    //create Future object
    Promise<String> promise = Promise.promise();
    //empty response injection
    promise.complete("Hello I am Promise result!!");
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //convert promise into future
    getSuccessPromise().future().onSuccess(System.out::println);
    getSuccessPromise1().onSuccess(System.out::println);

  }
}


public class PromiseMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=DriverManager.getConnection("connectionstring");
 QueryResult queryres=con.queryResult()
 List<T> results = formatResult(queryres)
 response.write(results)
 reponse.end();
 .......................................................................................
How the above task can be done in functional programming ; vertx?


Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.


Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with  output of getUser
                        |
		     if not
			 -error

Note : output of one function will be input to another function.


package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class CallbackVerticle extends AbstractVerticle {

  //getUser--->login--->other---untill you get final

  public Future<String> getUser() {
    Promise promise = Promise.promise();
    String userName = "admin";
    if (userName != null) {
      //output
      promise.complete(userName);
    } else {
      promise.fail(new RuntimeException("User not found"));
    }
    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise promise = Promise.promise();
    if (userName.equals("admin")) {
      //output
      promise.complete("login success");
    } else {
      promise.fail(new RuntimeException("login failed"));
    }
    return promise.future();
  }

  public Future<String> showPage(String status) {
    Promise promise = Promise.promise();
    if (status.equals("login success")) {
      //output
      promise.complete("Welcome to Admin page");
    } else {
      promise.fail(new RuntimeException("You are inside Guest page"));
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userasync -> {
      if (userasync.succeeded()) {
        System.out.println("getUser is called");
        login(userasync.result()).onComplete(loginasync -> {
          if (loginasync.succeeded()) {
            System.out.println("login is called");
            showPage(loginasync.result()).onComplete(pageasync -> {
              System.out.println("get page is called");
              if (pageasync.succeeded()) {
                System.out.println(pageasync.result());
              } else {
                System.out.println(pageasync.cause());
              }
            });
          } else {
            System.out.println(loginasync.cause());
          }
        });
      } else {
        System.out.println(userasync.cause());
      }
    });
  }
}

public class CallbackChainingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackChainingVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new CallbackVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
callback Hell:
 The way we write nested callbacks.
 doom of pyrmid

    getUser().onComplete(userasync -> {
      if (userasync.succeeded()) {
        System.out.println("getUser is called");
        login(userasync.result()).onComplete(loginasync -> {
          if (loginasync.succeeded()) {
            System.out.println("login is called");
            showPage(loginasync.result()).onComplete(pageasync -> {
              System.out.println("get page is called");
              if (pageasync.succeeded()) {
                System.out.println(pageasync.result());
              } else {
                System.out.println(pageasync.cause());
              }
            });
          } else {
            System.out.println(loginasync.cause());
          }
        });
      } else {
        System.out.println(userasync.cause());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!

This is called callback hell; The callback hell is way of writing complex callbacks.



can we escape from callback hell problem, how to write better callback based programming?

Yes! 


Solution to callback Hell:
..........................
compose method of Future & Promise 


package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class CallbackHellVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    //biz
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail("User not found");
    }

    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    //biz
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail("login failed");
    }
    return promise.future();
  }

  public Future<String> page(String status) {
    Promise<String> promise = Promise.promise();
    //biz
    if (status.equals("login success")) {
      promise.complete("Admin Page");
    } else {
      promise.fail("Guest Page");
    }
    return promise.future();
  }

  public void callbackHellCode() {
    getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });
  }

  //compose method of Future / Promise eleminate the complexity of callback nesting
  public void compose() {
    getUser()
      .compose(userName -> {
        return login(userName);
      })
      .compose(status -> {
        return page(status);
      })
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    getUser()
      .compose(userName -> login(userName))
      .compose(status -> page(status))
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    getUser()
      .compose(this::login)
      .compose(this::page)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

  }


  @Override
  public void start() throws Exception {
    super.start();
    //callbackHellCode();
    compose();
  }
}


public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHellSoultion.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new CallbackHellVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data Formate in vertx:

1.Buffer
2.JSON object

Buffer
JSON


Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically  as you write data to it.


package com.ibm.vertx.core.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BufferMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////
Non blocking apis:

->Creating TCP clients and servers
->Creating HTTP clients and servers
->Creating DNS clients
->Creating Datagram sockets
->Setting and cancelling periodic and one-shot timers
->Getting a reference to the event bus API
->Getting a reference to the file system API


Timer api:
.........


package com.ibm.vertx.core.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JsonVerticle.class);
  }

  public void createSimpleJSON() {

    JsonObject profile = new JsonObject();
    //add data; types
    profile.put("id", 1);
    profile.put("name", "Subramanian");
    profile.put("status", true);
    System.out.println(profile.getInteger("id"));
    System.out.println(profile.getString("name"));
    System.out.println(profile.getBoolean("status"));
    System.out.println(profile.encodePrettily());
  }

  public void createfluentJSON() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "ram")
      .put("status", true);
    System.out.println(profile.encodePrettily());
  }

  public void createNestedJSON() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject().put("street", "10th street").put("city", "coimbatore"));
    System.out.println(profile.encodePrettily());

  }

  public void createJSONArray() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray jsonArray = new JsonArray()
      .add(profile)
      .add(new JsonObject()
        .put("id", 2)
        .put("name", "Ram")
        .put("status", true)
        .put("address", new JsonObject()
          .put("city", "Chennai")
          .put("state", "Tamil Nadu")));
    System.out.println(jsonArray.encodePrettily());

  }

  public void mergeJson(JsonObject jsonObject) {
    JsonObject config = new JsonObject()
      .put("http.port", 8080)
      .mergeIn(jsonObject);
    System.out.println(config.encodePrettily());
  }

  public Future<JsonObject> getJsonFuture() {
    Promise<JsonObject> jsonPromise = Promise.promise();
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));
    jsonPromise.complete(profile);

    return jsonPromise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    createSimpleJSON();
    createfluentJSON();
    createNestedJSON();
    createJSONArray();
    mergeJson(new JsonObject().put("host", "localhost").put("ssl", true).put("http.port", 3000));
    getJsonFuture().onComplete(jsonObjectAsyncResult -> {
      if(jsonObjectAsyncResult.succeeded()){
        System.out.println(jsonObjectAsyncResult.result().encodePrettily());
      }
    });
  }
}

package com.ibm.vertx.core.async.timers;

import io.vertx.core.*;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

import java.util.Date;

class TimersVerticle extends AbstractVerticle {

  public void delay(long duration) {
    //timer api;
    vertx.setTimer(duration, timerHandler -> {
      //todo any task after timemout
      System.out.println("hello, i am delayed person");
    });
  }

  public Future<JsonObject> delayWithData(long duration) {
    Promise<JsonObject> promise = Promise.promise();

    vertx.setTimer(duration, timerHandler -> {
      //todo any task after timemout
      promise.complete(new JsonObject().put("id", 1).put("name", "subramaian"));
    });
    return promise.future();
  }

  public void heartBeat(Handler<AsyncResult<Date>> aHandler) {
    long timerid = vertx.setPeriodic(1000, phandler -> {
      //System.out.println(new Date());
      aHandler.handle(Future.succeededFuture(new Date()));
    });
    vertx.setTimer(10000, timerHandler -> {
      System.out.println("Stopping timer");
      vertx.cancelTimer(timerid);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
    delay(1000);
    delayWithData(5000).onComplete(jsonObjectAsyncResult -> {
      if (jsonObjectAsyncResult.succeeded()) {
        System.out.println(jsonObjectAsyncResult.result().encodePrettily());
      }
    });
    heartBeat(dateAsyncResult -> System.out.println(dateAsyncResult.result()));
    System.out.println("end");
  }
}

public class TimersMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimersMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new TimersVerticle());
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

Non blocking HTTP APPLICATION: Web Application:
..............................................

package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;


public class SimpleBasicHttpServer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleBasicHttpServer.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    HttpServer server = vertx.createHttpServer();

    //handle client request async
    server.requestHandler(request -> {
      //send a reponse
      HttpServerResponse response = request.response();
      response.end("Hello Http Server");
    });


    //start server
    server.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Ready at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server failed " + httpServerAsyncResult.cause());
      }
    });


  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////

HTTP Application:
................

How to build non blocking web application

vertx offers low level api called
 vertx.createHttpServer()

Objects:

1.HttpServer
2.HttpServerRequest
3.HttpServerResponse

All these objects are created already by vertx and only we use references.


package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class BasicHttpServer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicHttpServer.class);
  }

  public void createServer() {
    //create server object
    HttpServer httpServer = vertx.createHttpServer();

    //request handling
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      //send a response
      response.end("Hello Vertx Web Server");
    });

public void createFluentServer() {
    vertx.createHttpServer()
      .requestHandler(request -> request.response().end("Hello Vertx Web Server"))
      .listen(3001, serverHandler -> {
        if (serverHandler.succeeded()) {
          System.out.println("Server is ready at " + serverHandler.result().actualPort());
        } else {
          System.out.println(serverHandler.cause());
        }
      });
  }

    //start the server
    httpServer.listen(3000, serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Server is ready at " + serverHandler.result().actualPort());
      } else {
        System.out.println(serverHandler.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //createServer();
    createFluentServer();

  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class SendHtml extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SendHtml.class);
  }


  public void createFluentServer() {
    vertx.createHttpServer()
      .requestHandler(request -> request
        .response()
        .putHeader("content-type", "text/html")
        .end("<html><body><h1>Hello from vert.x!</h1></body></html>"))
      .listen(3001, serverHandler -> {
        if (serverHandler.succeeded()) {
          System.out.println("Server is ready at " + serverHandler.result().actualPort());
        } else {
          System.out.println(serverHandler.cause());
        }
      });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //createServer();
    createFluentServer();
  }
}


Sending JSON Response:
......................

package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class SendJson extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SendJson.class);
  }
  public void sendJson() {
    //create server
    HttpServer httpServer = vertx.createHttpServer();
    //start handling request-response in non blocking
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.putHeader("content-type", "application/json");
      JsonObject message = new JsonObject()
        .put("name", "Subramanian")
        .put("message", "welcome");
      response.end(message.encodePrettily());
    });
    //start the server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }
  @Override
  public void start() throws Exception {
    super.start();
    sendJson();
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////

RESTFull web services
Dynamic web application.


/api/products  - GET,POST,DELETE,PUT,...
/api/customers
/api/accounts


package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class RESTEndPointVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RESTEndPointVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    HttpServer server = vertx.createHttpServer();

    //handle client request async
    server.requestHandler(request -> {
      //send a reponse
      if (request.method() == HttpMethod.GET && request.path().equals("/api/message")) {
        JsonObject message = new JsonObject().put("message", "Hello");
        request
          .response()
          .putHeader("content-type", "application/json")
          .setStatusCode(200)
          .end(message.encodePrettily());
      } else if (request.method() == HttpMethod.GET && request.path().equals("/api/users")) {
        JsonArray users = new JsonArray();
        users.add(new JsonObject().put("id", 1).put("name", "subramanian"))
          .add(new JsonObject().put("id", 2).put("name", "Smith"));
        request
          .response()
          .putHeader("content-type", "application/json")
          .setStatusCode(200)
          .end(users.encodePrettily());
      }

    });


    //start server
    server.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Ready at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server failed " + httpServerAsyncResult.cause());
      }
    });
  }
}

Basic Vert.x-Web concepts
...........................

A Router is one of the core concepts of Vert.x-Web. It’s an object which maintains zero or more Routes .

A router takes an HTTP request and finds the first matching route for that request, and passes the request to that route.

The route can have a handler associated with it, which then receives the request. You then do something with the request, and then, either end it or pass it to the next matching handler.



HttpServer server = vertx.createHttpServer();

Router router = Router.router(vertx);

router.route().handler(routingContext -> {
  // This handler will be called for every request
  HttpServerResponse response = routingContext.response();
  response.putHeader("content-type", "text/plain");

  // Write to the response and end it
  response.end("Hello World from Vert.x-Web!");
});

server.requestHandler(router).listen(8080);


It basically does the same thing as the Vert.x Core HTTP server hello world example from the previous section, but this time using Vert.x-Web.

We create an HTTP server as before, then we create a router. Once we’ve done that we create a simple route with no matching criteria so it will match all requests that arrive on the server.

We then specify a handler for that route. That handler will be called for all requests that arrive on the server.

The object that gets passed into the handler is a RoutingContext - this contains the standard Vert.x HttpServerRequest and HttpServerResponse but also various other useful stuff that makes working with Vert.x-Web simpler.

For every request that is routed there is a unique routing context instance, and the same instance is passed to all handlers for that request.

Once we’ve set up the handler, we set the request handler of the HTTP server to pass all incoming requests to handle.

package com.ibm.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Route;
import io.vertx.ext.web.Router;

public class RouterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RouterVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    HttpServer server = vertx.createHttpServer();

    //Create Router; collection of routes, each each represents api.
    Router router = Router.router(vertx);

    //entry router//
    //this will be called for any request irrespective of method and url.
    router.route().handler(routingContext -> {
      System.out.println(routingContext.request().method() + " " + routingContext.request().path());
      //move the control to next route
      routingContext.next();
    });

    //other way of defining path
    Route myroute = router.route("/metrics");
    myroute.handler(routingContext -> {
      System.out.println("starting");
      routingContext.response().setChunked(true);
      routingContext.response().write("Staring....\n");
      routingContext.next();
    });
    myroute.handler(routingContext -> {
      System.out.println("going on");
      routingContext.response().write("Going on....\n");
      routingContext.next();
    });
    myroute.handler(routingContext -> {
      System.out.println("end");
      routingContext.response().write("End....\n");
      routingContext.next();
    });
    myroute.handler(routingContext -> {
      routingContext.response().write("Metrics done....\n");
      // Now end the response
      routingContext.response().end();
    });

    //fluent of above code
    router.route("/logs")
      .handler(routingContext -> {
        System.out.println("starting");
        routingContext.response().setChunked(true);
        routingContext.response().write("Staring....\n");
        routingContext.next();
      })
      .handler(routingContext -> {
        System.out.println("going on");
        routingContext.response().write("Going on....\n");
        routingContext.next();
      })
      .handler(routingContext -> {
        System.out.println("end");
        routingContext.response().write("End....\n");
        routingContext.next();
      })
      .handler(routingContext -> {
        routingContext.response().write("logs done....\n");
        // Now end the response
        routingContext.response().end();
      });


    //define routes
    //handler takes RoutingContext object, through which you can get Request and Response
    router.get("/api/message").handler(routingContext -> {
      JsonObject message = new JsonObject().put("message", "Hello");
      routingContext
        .response()
        .putHeader("content-type", "application/json")
        .setStatusCode(200)
        .end(message.encodePrettily());
    });
    //dynmaic route
    router.get("/api/message/:name").handler(routingContext -> {
      String name = routingContext.request().getParam("name");
      JsonObject message = new JsonObject().put("message", "Hello").put("name", name);
      routingContext
        .response()
        .putHeader("content-type", "application/json")
        .setStatusCode(200)
        .end(message.encodePrettily());
    });
    router.get("/api/users").handler(routingContext -> {
      JsonArray users = new JsonArray();
      users.add(new JsonObject().put("id", 1).put("name", "subramanian"))
        .add(new JsonObject().put("id", 2).put("name", "Smith"));
      routingContext
        .response()
        .putHeader("content-type", "application/json")
        .setStatusCode(200)
        .end(users.encodePrettily());
    });

    server.requestHandler(router);
    server.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Ready at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server failed " + httpServerAsyncResult.cause());
      }
    });
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////

REST API ; Based on resources;

/api/customers - get,post,delete,put,
/api/orders -- get,post,delete,put,
/api/products -- get,post,delete,put,

SubRouters 
package com.ibm.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;


public class ResourceBasedRouting extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ResourceBasedRouting.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    HttpServer server = vertx.createHttpServer();

    Router customerRouter = Router.router(vertx);
    Router productRouter = Router.router(vertx);

    //custoemrs
    customerRouter.get("/list").handler(routingContext -> {
      JsonArray users = new JsonArray();
      users.add(new JsonObject().put("id", 1).put("name", "subramanian"))
        .add(new JsonObject().put("id", 2).put("name", "Smith"));
      routingContext
        .response()
        .putHeader("content-type", "application/json")
        .setStatusCode(200)
        .end(users.encodePrettily());
    });

    //prouust
    productRouter.get("/list").handler(routingContext -> {
      JsonArray users = new JsonArray();
      users.add(new JsonObject().put("id", 1).put("name", "phone"))
        .add(new JsonObject().put("id", 2).put("name", "tv"));
      routingContext
        .response()
        .putHeader("content-type", "application/json")
        .setStatusCode(200)
        .end(users.encodePrettily());
    });

    //Application Router /route Router
    Router mainRouter = Router.router(vertx);
    //binding subrouters with main router
    mainRouter.mountSubRouter("/api/customers", customerRouter);
    mainRouter.mountSubRouter("/api/products", productRouter);

    server.requestHandler(mainRouter);

    server.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Ready at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server failed " + httpServerAsyncResult.cause());
      }
    });
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
package com.ibm.vertx.core.http;

import io.vertx.core.Vertx;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.Json;
import io.vertx.ext.web.Route;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

import java.util.ArrayList;
import java.util.List;

class Employee {
  private int id;
  private String name;
  private String dept;
  private double salary;

  public Employee(int id, String name, String dept, double salary) {
    super();
    this.id = id;
    this.name = name;
    this.dept = dept;
    this.salary = salary;
  }

  public Employee() {
    super();
    // TODO Auto-generated constructor stub
  }

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public String getDept() {
    return dept;
  }

  public void setDept(String dept) {
    this.dept = dept;
  }

  public double getSalary() {
    return salary;
  }

  public void setSalary(double salary) {
    this.salary = salary;
  }

}

public class RestPost {
  public static void main(String[] args) {
    List<Employee> employees = new ArrayList<>();
    Vertx vertx = Vertx.vertx();
    HttpServer server = vertx.createHttpServer();
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());
    Route postHandler = router
      .post("/addEmployee")
      .handler(routingContext -> {
        final Employee employee = Json.decodeValue(routingContext.getBody(), Employee.class);
        HttpServerResponse serverResponse = routingContext.response();
        serverResponse.setChunked(true);
        System.out.println(Json.encodePrettily(employee));
        employees.add(employee);
        serverResponse.end(employees.size() + " Employee added successfully...");
      });
    server.requestHandler(router).listen(9090);

  }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
Micro service patterns:

verticle communication:
.......................

->HTTP based communication
->TCP based communication
-Message driven communication.


Vertx Verticle communication via http:
.......................................

1.HTTPClient Core lib - deprecated.
2.WebClient
Micro service applications:
..........................

Service :

 Representation of biz functionality
 Services are represented by objects
 
An application is collection of services.

-Services can talk each other 
  Why
    --to exchange message

How data/message can be shared?

HTTP style  --HTTP Protocal
Distributed Message Brokers - AMQP,...
IPC --TCP /


HTTP Communication:

-Provder --- web rest end point
-Consumer ---another service/web end point
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Web Client:

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>3.9.3</version>
</dependency>

The Web Client makes easy to do HTTP request/response interactions with a web server


package com.ibm.vertx.microservices.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;

public class ProviderServiceVerticle extends AbstractVerticle {

  public void home(RoutingContext routingContext) {
    //using routing context , you can get request and response objects
    routingContext.response().putHeader("content-type", "text/html").end("<h1>Home</h1>");
  }

  public void start() throws Exception {
    super.start();
    //create server object
    HttpServer httpServer = vertx.createHttpServer();

    //Routers : method and url mapping using vertx-web module
    //router is entry, which has collection of routes
    Router router = Router.router(vertx);
    //routes
    //router.HTTPmethod("url)
    router.get("/").handler(this::home);
    router.get("/api/hello").handler(routingContext -> {
      //using routing context , you can get request and response objects
      routingContext.response().putHeader("content-type", "text/html").end("<h1>Hello!!</h1>");
    });
    router.get("/api/hai").handler(routingContext -> {
      //using routing context , you can get request and response objects
      routingContext.response().putHeader("content-type", "text/html").end("<h1>Hai!!</h1>");
    });
    //request handling
    httpServer.requestHandler(router);
    //start the server
    httpServer.listen(3000, serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Provider Server is ready at " + serverHandler.result().actualPort());
      } else {
        System.out.println(serverHandler.cause());
      }
    });

  }
}


package com.ibm.vertx.microservices.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpServer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

public class ConsumerServiceVerticle extends AbstractVerticle {
  WebClient webClient;

  public void home(RoutingContext routingContext) {
    //create WebClient instance
    webClient = WebClient.create(vertx);
    Integer port = 3000;
    String host = "localhost";
    String url = "/";
    webClient.get(port, host, url).send(ar -> {
      if (ar.succeeded()) {
        //Obtain Response
        HttpResponse<Buffer> response = ar.result();
        System.out.println(response.bodyAsString());
        routingContext.response().end(response.bodyAsString());
      } else {
        System.out.println(ar.cause());
      }
    });

  }

  public void hello(RoutingContext routingContext) {
    //create WebClient instance
    webClient = WebClient.create(vertx);
    Integer port = 3000;
    String host = "localhost";
    String url = "/api/hello";
    webClient.get(port, host, url).send(ar -> {
      if (ar.succeeded()) {
        //Obtain Response
        HttpResponse<Buffer> response = ar.result();
        System.out.println(response.bodyAsString());
        routingContext.response().end(response.bodyAsString());
      } else {
        System.out.println(ar.cause());
      }
    });


  }

  @Override
  public void start() throws Exception {
    super.start();
    HttpServer httpServer = vertx.createHttpServer();
    //Routers : method and url mapping using vertx-web module
    //router is entry, which has collection of routes
    Router router = Router.router(vertx);
    //routes
    //router.HTTPmethod("url)
    router.get("/").handler(this::home);
    router.get("/api/greeter/hello").handler(this::hello);

    //request handling
    httpServer.requestHandler(router);

    httpServer.listen(3001, handler -> {
      if (handler.succeeded()) {
        System.out.println("Consumer Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Consumer Server is down!!!" + handler.cause());
      }
    });
  }
}
package com.ibm.vertx.microservices.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class HttpMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HttpMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ProviderServiceVerticle());
    vertx.deployVerticle(new ConsumerServiceVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                             Service Types
                                                 |
                                  ------------------------------------
                                 Front End Service                Back End Service
                                     |                                  |
                                public Rest endpoint              Private Services.


Public Rest endpoint services are communicated via Http protocal.
  -Web --> WebClient

Private Services are commmunicated via tcp ,message brokers like protocal.


Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon






package com.ibm.vertx.microservices.communication.eventbus;


//PUB-SUB - ONE TO many


import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.http.HttpServer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;


class Address {
  public static String PUB_SUB_ADDRESS = "news.in.covid";
  public static String POINT_TO_POINT = "covid.fin.request";
  public static String REQUEST_REPLY = "covid.lab.report";

}

class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply("Patient is Crictal, Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class ReportVerticle extends AbstractVerticle {

  public void sendReport() {
    vertx.setTimer(5000, ar -> {
      String message = "Report of Mr.x";
      vertx.eventBus().request(Address.REQUEST_REPLY, message, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
        } else {
          System.out.println(asyncResult.cause());
        }
      });
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    sendReport();
  }
}

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  public void consume2() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 2 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
    consume2();
  }
}


//point to point publisher
class FinanceRequestVerticle extends AbstractVerticle {

  public void requestFinance() {
    System.out.println("Finance Request started....");
    vertx.setTimer(5000, ar -> {
      //point to point : send method
      String message = "Dear Team, We request that we want 1 Billion Money for Covid";
      //point to point ; send
      vertx.eventBus().send(Address.POINT_TO_POINT, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    requestFinance();
  }
}


/////////////////////////////
//pub-sub ; one provider many consumer
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

//publisher publish news to all news tv channels
class PublisherVerticle extends AbstractVerticle {

  public void publish() {
    //one to many
    vertx.setTimer(1000, handler -> {
      String message = "Last 24 Hrs covid count is 80000";
      EventBus eventBus = vertx.eventBus();
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
    });
  }

  public void publishviaHttp() {
    HttpServer httpServer = vertx.createHttpServer();
    Router router = Router.router(vertx);
    router.get("/api/notification").handler(routingContext -> {
      String message = "Last 24 Hrs covid count is 80000";
      EventBus eventBus = vertx.eventBus();
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      routingContext.response().end("Published");
    });
    httpServer.requestHandler(router);
    httpServer.listen(9000, httpServerAsyncResult -> {
      System.out.println("Notification Server " + httpServerAsyncResult.result().actualPort());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    // publish();
    publishviaHttp();
  }
}

public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  public void pubsub() {
    vertx.deployVerticle(new PublisherVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
  }

  public void pointToPoint() {
    vertx.deployVerticle(new CenertalFinanceVerticle());
    vertx.deployVerticle(new FinanceRequestVerticle());
  }

  public void requestReply() {
    vertx.deployVerticle(new ReportVerticle());
    vertx.deployVerticle(new LabVerticle());
  }

  @Override
  public void start() throws Exception {
    super.start();
    // pubsub();
    //pointToPoint();
    requestReply();
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

Data Sources : JDBC Application ; Web 

Todo:

1.Vert.x web.
2.Vert.x JDBC client to provide an asynchronous API over JDBC.
3.Apache FreeMarker to render server-side pages as it is an uncomplicated template engine.
4.Txtmark to render Markdown text to HTML, allowing the edition of wiki pages in Markdown.

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-templ-freemarker</artifactId>
    </dependency>
    <dependency>
      <groupId>com.github.rjeschke</groupId>
      <artifactId>txtmark</artifactId>
      <version>0.13</version>
    </dependency>


Simple Application:
package com.ibm.vertx.app.web.jdbc;

import com.github.rjeschke.txtmark.Processor;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.templ.freemarker.FreeMarkerTemplateEngine;

import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

class WikiVerticle extends AbstractVerticle {
  //Sql Queries
  private static final String SQL_CREATE_PAGES_TABLE = "create table if not exists Pages (Id integer identity primary key, Name varchar(255) unique, Content clob)";
  private static final String SQL_GET_PAGE = "select Id, Content from Pages where Name = ?";
  private static final String SQL_CREATE_PAGE = "insert into Pages values (NULL, ?, ?)";
  private static final String SQL_SAVE_PAGE = "update Pages set Content = ? where Id = ?";
  private static final String SQL_ALL_PAGES = "select Name from Pages";
  private static final String SQL_DELETE_PAGE = "delete from Pages where Id = ?";
  private static final String EMPTY_PAGE_MARKDOWN =
    "# A new page\n" +
      "\n" +
      "Feel-free to write in Markdown!\n";
  //declarations
  private JDBCClient dbClient;
  //Template engine
  private FreeMarkerTemplateEngine templateEngine;

  public Future<Void> prepareDatabase() {
    Promise<Void> promise = Promise.promise();
    //initialize database
    dbClient = JDBCClient.createShared(vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:file:db/wiki")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30));

    //inital table creation.
    dbClient.getConnection(ar -> {
      if (ar.failed()) {
        System.out.println("Could not open a database connection" + ar.cause());
        promise.fail(ar.cause());
      } else {
        SQLConnection connection = ar.result();
        connection.execute(SQL_CREATE_PAGES_TABLE, create -> {
          connection.close();
          if (create.failed()) {
            System.out.println("Database preparation error" + create.cause());
            promise.fail(create.cause());
          } else {
            promise.complete();
          }
        });
      }
    });

    return promise.future();
  }

  private void pageCreateHandler(RoutingContext context) {
    String pageName = context.request().getParam("name");
    String location = "/wiki/" + pageName;
    if (pageName == null || pageName.isEmpty()) {
      location = "/";
    }
    context.response().setStatusCode(303);
    context.response().putHeader("Location", location);
    context.response().end();
  }

  private void indexHandler(RoutingContext context) {
    dbClient.getConnection(car -> {
      if (car.succeeded()) {
        SQLConnection connection = car.result();
        connection.query(SQL_ALL_PAGES, res -> {
          connection.close();

          if (res.succeeded()) {
            //rows
            List<String> pages = res.result() // <1>
              .getResults() //convert result into java 8 stream.
              .stream()
              .map(json -> json.getString(0))
              .sorted()
              .collect(Collectors.toList());

            //send context data to web page
            context.put("title", "IBM - Wiki home");
            //table rows are stored inside context object , so that you can access where ever want
            context.put("pages", pages);
            templateEngine.render(context.data(), "templates/index.ftl", ar -> {
              if (ar.succeeded()) {
                context.response().putHeader("Content-Type", "text/html");
                context.response().end(ar.result());
              } else {
                context.fail(ar.cause());
              }
            });

          } else {
            context.fail(res.cause());
          }
        });
      } else {
        context.fail(car.cause());
      }
    });
  }

  private void pageUpdateHandler(RoutingContext context) {
    String id = context.request().getParam("id");   // <1>
    String title = context.request().getParam("title");
    String markdown = context.request().getParam("markdown");
    boolean newPage = "yes".equals(context.request().getParam("newPage"));  // <2>

    dbClient.getConnection(car -> {
      if (car.succeeded()) {
        SQLConnection connection = car.result();
        String sql = newPage ? SQL_CREATE_PAGE : SQL_SAVE_PAGE;
        JsonArray params = new JsonArray();   // <3>
        if (newPage) {
          params.add(title).add(markdown);
        } else {
          params.add(markdown).add(id);
        }
        connection.updateWithParams(sql, params, res -> {   // <4>
          connection.close();
          if (res.succeeded()) {
            context.response().setStatusCode(303);    // <5>
            context.response().putHeader("Location", "/wiki/" + title);
            context.response().end();
          } else {
            context.fail(res.cause());
          }
        });
      } else {
        context.fail(car.cause());
      }
    });
  }

  private void pageRenderingHandler(RoutingContext context) {
    String page = context.request().getParam("page");   // <1>

    dbClient.getConnection(car -> {
      if (car.succeeded()) {

        SQLConnection connection = car.result();
        connection.queryWithParams(SQL_GET_PAGE, new JsonArray().add(page), fetch -> {  // <2>
          connection.close();
          if (fetch.succeeded()) {

            JsonArray row = fetch.result().getResults()
              .stream()
              .findFirst()
              .orElseGet(() -> new JsonArray().add(-1).add(EMPTY_PAGE_MARKDOWN));
            Integer id = row.getInteger(0);
            String rawContent = row.getString(1);

            context.put("title", page);
            context.put("id", id);
            context.put("newPage", fetch.result().getResults().size() == 0 ? "yes" : "no");
            context.put("rawContent", rawContent);
            context.put("content", Processor.process(rawContent));  // <3>
            context.put("timestamp", new Date().toString());

            templateEngine.render(context.data(), "templates/page.ftl", ar -> {
              if (ar.succeeded()) {
                context.response().putHeader("Content-Type", "text/html");
                context.response().end(ar.result());
              } else {
                context.fail(ar.cause());
              }
            });
          } else {
            context.fail(fetch.cause());
          }
        });

      } else {
        context.fail(car.cause());
      }
    });
  }

  private void pageDeletionHandler(RoutingContext context) {
    String id = context.request().getParam("id");
    dbClient.getConnection(car -> {
      if (car.succeeded()) {
        SQLConnection connection = car.result();
        connection.updateWithParams(SQL_DELETE_PAGE, new JsonArray().add(id), res -> {
          connection.close();
          if (res.succeeded()) {
            context.response().setStatusCode(303);
            context.response().putHeader("Location", "/");
            context.response().end();
          } else {
            context.fail(res.cause());
          }
        });
      } else {
        context.fail(car.cause());
      }
    });
  }

  private Future<Void> startHttpServer() {
    Promise<Void> promise = Promise.promise();
    HttpServer server = vertx.createHttpServer();
    Router router = Router.router(vertx);

    router.get("/").handler(this::indexHandler);
    router.get("/wiki/:page").handler(this::pageRenderingHandler); // <3>
    router.post().handler(BodyHandler.create());  // <4>
    router.post("/save").handler(this::pageUpdateHandler);
    router.post("/create").handler(this::pageCreateHandler);
    router.post("/delete").handler(this::pageDeletionHandler);


    templateEngine = FreeMarkerTemplateEngine.create(vertx);
    server
      .requestHandler(router)
      .listen(8080, ar -> {
        if (ar.succeeded()) {
          System.out.println("HTTP server running on port 8080");
          promise.complete();
        } else {
          System.out.println("Could not start a HTTP server" + ar.cause());
          promise.fail(ar.cause());
        }
      });
    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    //tell this verticle start method is finalized whith onComplete
    // prepareDatabase().compose(v -> startHttpServer()).onComplete(startPromise);
    Future<Void> steps = prepareDatabase().compose(v -> startHttpServer());
    steps.onComplete(startPromise);
  }
}

public class WikiApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WikiApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new WikiVerticle());
  }
}

package com.ibm.vertx.app.web.jdbc;

import com.github.rjeschke.txtmark.Processor;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.templ.freemarker.FreeMarkerTemplateEngine;

import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

class WikiVerticle extends AbstractVerticle {
  //Sql Queries
  private static final String SQL_CREATE_PAGES_TABLE = "create table if not exists Pages (Id integer identity primary key, Name varchar(255) unique, Content clob)";
  private static final String SQL_GET_PAGE = "select Id, Content from Pages where Name = ?";
  private static final String SQL_CREATE_PAGE = "insert into Pages values (NULL, ?, ?)";
  private static final String SQL_SAVE_PAGE = "update Pages set Content = ? where Id = ?";
  private static final String SQL_ALL_PAGES = "select Name from Pages";
  private static final String SQL_DELETE_PAGE = "delete from Pages where Id = ?";
  private static final String EMPTY_PAGE_MARKDOWN =
    "# A new page\n" +
      "\n" +
      "Feel-free to write in Markdown!\n";
  //declarations
  private JDBCClient dbClient;
  //Template engine
  private FreeMarkerTemplateEngine templateEngine;

  public Future<Void> prepareDatabase() {
    Promise<Void> promise = Promise.promise();
    //initialize database
    dbClient = JDBCClient.createShared(vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:file:db/wiki")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30));

    //inital table creation.
    dbClient.getConnection(ar -> {
      if (ar.failed()) {
        System.out.println("Could not open a database connection" + ar.cause());
        promise.fail(ar.cause());
      } else {
        SQLConnection connection = ar.result();
        connection.execute(SQL_CREATE_PAGES_TABLE, create -> {
          connection.close();
          if (create.failed()) {
            System.out.println("Database preparation error" + create.cause());
            promise.fail(create.cause());
          } else {
            promise.complete();
          }
        });
      }
    });

    return promise.future();
  }

  private void pageCreateHandler(RoutingContext context) {
    String pageName = context.request().getParam("name");
    String location = "/wiki/" + pageName;
    if (pageName == null || pageName.isEmpty()) {
      location = "/";
    }
    context.response().setStatusCode(303);
    context.response().putHeader("Location", location);
    context.response().end();
  }

  private void indexHandler(RoutingContext context) {
    dbClient.getConnection(car -> {
      if (car.succeeded()) {
        SQLConnection connection = car.result();
        connection.query(SQL_ALL_PAGES, res -> {
          connection.close();

          if (res.succeeded()) {
            //rows
            List<String> pages = res.result() // <1>
              .getResults() //convert result into java 8 stream.
              .stream()
              .map(json -> json.getString(0))
              .sorted()
              .collect(Collectors.toList());

            //send context data to web page
            context.put("title", "IBM - Wiki home");
            //table rows are stored inside context object , so that you can access where ever want
            context.put("pages", pages);
            templateEngine.render(context.data(), "templates/index.ftl", ar -> {
              if (ar.succeeded()) {
                context.response().putHeader("Content-Type", "text/html");
                context.response().end(ar.result());
              } else {
                context.fail(ar.cause());
              }
            });

          } else {
            context.fail(res.cause());
          }
        });
      } else {
        context.fail(car.cause());
      }
    });
  }

  private void pageUpdateHandler(RoutingContext context) {
    String id = context.request().getParam("id");   // <1>
    String title = context.request().getParam("title");
    String markdown = context.request().getParam("markdown");
    boolean newPage = "yes".equals(context.request().getParam("newPage"));  // <2>

    dbClient.getConnection(car -> {
      if (car.succeeded()) {
        SQLConnection connection = car.result();
        String sql = newPage ? SQL_CREATE_PAGE : SQL_SAVE_PAGE;
        JsonArray params = new JsonArray();   // <3>
        if (newPage) {
          params.add(title).add(markdown);
        } else {
          params.add(markdown).add(id);
        }
        connection.updateWithParams(sql, params, res -> {   // <4>
          connection.close();
          if (res.succeeded()) {
            context.response().setStatusCode(303);    // <5>
            context.response().putHeader("Location", "/wiki/" + title);
            context.response().end();
          } else {
            context.fail(res.cause());
          }
        });
      } else {
        context.fail(car.cause());
      }
    });
  }

  private void pageRenderingHandler(RoutingContext context) {
    String page = context.request().getParam("page");   // <1>

    dbClient.getConnection(car -> {
      if (car.succeeded()) {

        SQLConnection connection = car.result();
        connection.queryWithParams(SQL_GET_PAGE, new JsonArray().add(page), fetch -> {  // <2>
          connection.close();
          if (fetch.succeeded()) {

            JsonArray row = fetch.result().getResults()
              .stream()
              .findFirst()
              .orElseGet(() -> new JsonArray().add(-1).add(EMPTY_PAGE_MARKDOWN));
            Integer id = row.getInteger(0);
            String rawContent = row.getString(1);

            context.put("title", page);
            context.put("id", id);
            context.put("newPage", fetch.result().getResults().size() == 0 ? "yes" : "no");
            context.put("rawContent", rawContent);
            context.put("content", Processor.process(rawContent));  // <3>
            context.put("timestamp", new Date().toString());

            templateEngine.render(context.data(), "templates/page.ftl", ar -> {
              if (ar.succeeded()) {
                context.response().putHeader("Content-Type", "text/html");
                context.response().end(ar.result());
              } else {
                context.fail(ar.cause());
              }
            });
          } else {
            context.fail(fetch.cause());
          }
        });

      } else {
        context.fail(car.cause());
      }
    });
  }

  private void pageDeletionHandler(RoutingContext context) {
    String id = context.request().getParam("id");
    dbClient.getConnection(car -> {
      if (car.succeeded()) {
        SQLConnection connection = car.result();
        connection.updateWithParams(SQL_DELETE_PAGE, new JsonArray().add(id), res -> {
          connection.close();
          if (res.succeeded()) {
            context.response().setStatusCode(303);
            context.response().putHeader("Location", "/");
            context.response().end();
          } else {
            context.fail(res.cause());
          }
        });
      } else {
        context.fail(car.cause());
      }
    });
  }

  private Future<Void> startHttpServer() {
    Promise<Void> promise = Promise.promise();
    HttpServer server = vertx.createHttpServer();
    Router router = Router.router(vertx);

    router.get("/").handler(this::indexHandler);
    router.get("/wiki/:page").handler(this::pageRenderingHandler); // <3>
    router.post().handler(BodyHandler.create());  // <4>
    router.post("/save").handler(this::pageUpdateHandler);
    router.post("/create").handler(this::pageCreateHandler);
    router.post("/delete").handler(this::pageDeletionHandler);


    templateEngine = FreeMarkerTemplateEngine.create(vertx);
    server
      .requestHandler(router)
      .listen(8080, ar -> {
        if (ar.succeeded()) {
          System.out.println("HTTP server running on port 8080");
          promise.complete();
        } else {
          System.out.println("Could not start a HTTP server" + ar.cause());
          promise.fail(ar.cause());
        }
      });
    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    //tell this verticle start method is finalized whith onComplete
    // prepareDatabase().compose(v -> startHttpServer()).onComplete(startPromise);
    Future<Void> steps = prepareDatabase().compose(v -> startHttpServer());
    steps.onComplete(startPromise);
  }
}

public class WikiApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WikiApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new WikiVerticle());
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
Configuration System in vertx:
..............................

Any Object can be configured via Configuration Object

1.if you want configure "Verticle" via DeploymentOptions

io.vertx.core.DeploymentOptions:
Options for configuring a verticle deployment.

eg :
vertx.deployverticle(VerticleName,callback,DeploymentOptions);

2.if you want to configure "Vertx" itself VertxOptions.

  To configure vertx engine via coding.

3.if you want to configure "HttpServer" ,HttpServerOptions
   if you want to supply server configurations like ssl,security....

4.if you want to configure "EventBus" ,DeliveryOptions

Delivery options are used to configure message delivery.


Note: 
  Any configuration , which is supplied and read via "JsonObject" only

etc.................................................................................................


Use case how to supply config data via DeploymentOptions to verticle, how to read?

How to supply configuration info to Verticle?


 -can read config  data from the Vertx Context Object
     via DeploymentOptions we need to inject config data.

-via DeploymentOptions while verticle is being deployed.

-How to read configuration which was supplied via DeploymentOptions

AbstractVerticle has an api 

public JsonObject config()
Get the configuration of the verticle.
This can be specified when the verticle is deployed.


package com.ibm.vertx.microservices.config;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ApplicationConfigVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    //read config
    vertx
      .createHttpServer()
      .requestHandler(request -> {
        System.out.println(config().getString("name"));
        request.response().end(config().getString("message"));
      })
      .listen(config().getInteger("http.port",8080), ar -> {
        System.out.println("Server is ready at " + ar.result().actualPort());
      });
  }
}


public class VerticleConfiguration extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(VerticleConfiguration.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    DeploymentOptions options = new DeploymentOptions();

    JsonObject applicationConfig = new JsonObject()
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .put("state", "TN");

    JsonObject config = new JsonObject()
      .put("http.port", 3000)
      .put("message", "Hello")
      .mergeIn(applicationConfig);

    options.setConfig(config);
    //inject config data to verticlie
    vertx.deployVerticle(new ApplicationConfigVerticle(), options);


  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

How to refactor configuration?
package com.ibm.vertx.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ExternalConfigVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(config().encodePrettily());

  }
}

class ApplicationConfigVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    //read config
    vertx
      .createHttpServer()
      .requestHandler(request -> {
        System.out.println(config().getString("name"));
        request.response().end(config().getString("message"));
      })
      .listen(config().getInteger("http.port", 8080), ar -> {
        System.out.println("Server is ready at " + ar.result().actualPort());
      });
  }
}


public class VerticleConfiguration extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(VerticleConfiguration.class);
  }

  public Future<JsonObject> getConfig() {
    Promise<JsonObject> promise = Promise.promise();
    //store options
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));
    //config reteriver
    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));
    //read configuration
    retriever.getConfig(config -> {
      if (config.succeeded()) {
        promise.complete(config.result());
      } else {
        promise.fail("Config Error : " + config.cause());
      }
    });
    return promise.future();

  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    DeploymentOptions options = new DeploymentOptions();

    JsonObject applicationConfig = new JsonObject()
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .put("state", "TN");

    JsonObject config = new JsonObject()
      .put("http.port", 3000)
      .put("message", "Hello")
      .mergeIn(applicationConfig);

    options.setConfig(config);
    //inject config data to verticlie
    vertx.deployVerticle(new ApplicationConfigVerticle(), options);

    getConfig().onSuccess(myconfig -> {
      //System.out.println(myconfig.encodePrettily());
//      JsonObject appconfig = new JsonObject()
//        .put("name", "Subramnaian")
//        .put("message", "Hello!!")
//        .mergeIn(myconfig);
      DeploymentOptions myoptions = new DeploymentOptions().setConfig(myconfig);
      vertx.deployVerticle(new ExternalConfigVerticle(), myoptions);
    });


  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Golden Rule : Dont block event loop:
.....................................

There is no gurantee that vertx can offer 100% non blocking, what if i want to write blocking opertions inside vertx.

-Non blocking operations are handled by "Event Loop" Thread.
-Blocking operations should be off loaded outside event loop thread, grab result carefully without  blocking event loop.

does vertx supports blocking code? is blocking is neccessary?How do we write blocking code? 

Yes! vertx supports blocking code.

Yes!, you cant write 100% non blocking code
.
Use case : 

You are building vertx application, vertx application need to talk to hibernate/jpa layer.
Vertx is non blocking but hibernate blocking.

if you write blocking inside non blocking vertx will throw error, but how to bridge blocking with non-blocking.

Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api 
.....

Event loop thread can wait for 2000ms - default wait duration : event loop thread in vertx cant 
wait / be blocked for 2000ms.

Types of verticles;

1.event loop verticle /Standard verticle

   verticle is processed by event loop thread.
   all verticles by default event loop thread.
   used for non blocking operations mostly

2.worker verticle
   verticle is processed by a separte threads called worker pool threads.
   worker pool threads used only for blocking operations.
   worker verticles are used for running blocking operations.

How to create worker verticle?
  
 Using DeploymentOptions  , there is a method called setWorker(true);
Deploy the verticle with dp of setworker(true)


package com.ibm.vertx.microservices.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.example.util.Runner;

class MyBlockingVerticle extends AbstractVerticle {
  private void blockeMe() {
    try {
      Thread.sleep(10000);
      System.out.println("i am ready after blocking");
    } catch (InterruptedException es) {

    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    blockeMe();
  }
}


public class BlockingVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //worker verticles
    DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new MyBlockingVerticle(), options);
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.microservices.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class ExcuteBlockingApiVerticle extends AbstractVerticle {

  private void sayHello(Promise<String> promise) {
    System.out.println("Say Hello : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up, to send data to Non blocking Service");
      //this result will be accessed inside non blocking code
      promise.complete("Hey this is blocking Result");

    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }

  private void resultHandler(AsyncResult<String> ar) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (ar.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(ar.result());
    } else {
      System.out.println(ar.cause().getMessage());
    }
  }

  public void exchange() {
    //run blocking ,blocking code result i need inside nonblocking
    vertx.executeBlocking(this::sayHello, this::resultHandler);
  }
  public void httpblocking() {
    vertx.createHttpServer().requestHandler(request -> {
      vertx.<String>executeBlocking(promise -> {
        // Do the blocking operation in here
        // Imagine this was a call to a blocking API to get the result
        try {
          Thread.sleep(5000);
        } catch (Exception ignore) {
        }
        String result = "hello , i am blocked";

        promise.complete(result);

      }, res -> {
        if (res.succeeded()) {
          request.response().putHeader("content-type", "text/plain").end(res.result());
        } else {
          res.cause().printStackTrace();
        }
      });

    }).listen(8080);
  }
  public void httpRouterBlocking() {
    HttpServer server = vertx.createHttpServer();
    Router router = Router.router(vertx);
    router.get("/blocking").blockingHandler(routingContext -> {
      try {
        //blocking code
        Thread.sleep(5000);
      } catch (Exception e) {

      }
      routingContext.response().end("Blocking result");
    });

    server.requestHandler(router);


    server.listen(8081, handler -> {
      if (handler.succeeded()) {
        System.out.println(handler.result().actualPort());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(this.getClass().getName() + "is running on" + Thread.currentThread().getName());
    //exchange();
    //httpblocking();
    httpRouterBlocking();
  }
}

class MyBlockingVerticle extends AbstractVerticle {
  private void blockeMe() {
    try {
      Thread.sleep(10000);
      System.out.println("i am ready after blocking");
    } catch (InterruptedException es) {

    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    blockeMe();
  }
}


public class BlockingVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //worker verticles
    DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new MyBlockingVerticle(), options);
    vertx.deployVerticle(new ExcuteBlockingApiVerticle());
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Resilence: How to surive from service failures and slow?
........................................................

Api call to another api

 Api-a----------------calls Api-b


possiblity:

api-a may get data.
api-a may get error
api-a may not get either data or error with in time, api-b slow
api-a is allowed to call api-b for more than 5 users concurrently.

CircuitBreaker is desigin pattern used for failure management.

CircuitBreaker similar to try...catch block in traditional programming.

try{
 
  risky code
  code subject to fail any time
}
catch(){
 if something went wrong handle it.
}

CircuitBreaker is delclartive rules engine for fault management.

rule is 
if caller not getting response with in time limit,CircuitBreaker Will providing alternate result.

CircuitBreaker{

  risky code 
}
open circuite,provide alternate soultion.

vertx-provides a module called vertx-CircuitBreaker , to write fail-fast safer distributed programming.




package com.ibm.vertx.microservices.cb;

import io.vertx.circuitbreaker.CircuitBreaker;
import io.vertx.circuitbreaker.CircuitBreakerOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

class SomeServiceVerticle extends AbstractVerticle {
  public void slowService() {
    vertx.createHttpServer().requestHandler(request -> {
      vertx.<String>executeBlocking(promise -> {
        // Do the blocking operation in here
        // Imagine this was a call to a blocking API to get the result
        try {
          Thread.sleep(5000);
        } catch (Exception ignore) {
        }
        String result = "hello , i am coming late , can you wait for me?";
        promise.complete(result);

      }, res -> {

        if (res.succeeded()) {
          request.response().putHeader("content-type", "text/plain").end(res.result());

        } else {
          res.cause().printStackTrace();
        }
      });

    }).listen(3000);
  }

  @Override
  public void start() throws Exception {
    super.start();
    slowService();
  }
}

public class CircuitBreakerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CircuitBreakerVerticle.class);
  }

  public void testCircuitBreaker() {
    CircuitBreakerOptions options = options = new CircuitBreakerOptions();
    options.setMaxFailures(2);// no of failures will be allowed , after that , ciruit will open
    options.setTimeout(6000); // consider a failure if the operation deos not succeed in time
    options.setFallbackOnFailure(true); // if any failure, should i handle fallback or not

    CircuitBreaker circuitBreaker = CircuitBreaker.create("my-circuit-breaker", vertx, options);
    circuitBreaker.executeWithFallback(future -> {
      //risky code
      WebClient client = WebClient.create(vertx);
      client.get(3000, "localhost", "/").send(ar -> {
        // Obtain response
        HttpResponse<Buffer> response = ar.result();
        if (response.statusCode() != 200) {
          future.fail("HTTP error");
        } else {
          future.complete(response.bodyAsString());
        }
      });
    }, v -> {
      // Executed when the circuit is opened
      return "Hello, I am fallback";
    }).onComplete(ar -> {
      // Do something with the result
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause());

      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new SomeServiceVerticle());

    vertx.setTimer(2000, h -> {
      testCircuitBreaker();
    });


  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////


package com.ibm.vertx.rx;
import io.reactivex.Single;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.ext.web.Router;
import io.vertx.reactivex.ext.web.RoutingContext;
import io.vertx.reactivex.ext.web.client.HttpRequest;
import io.vertx.reactivex.ext.web.client.HttpResponse;
import io.vertx.reactivex.ext.web.client.WebClient;
import io.vertx.reactivex.ext.web.codec.BodyCodec;

class HelloConsumerMicroservice extends AbstractVerticle {
  private WebClient client;

  @Override
  public void start() throws Exception {
    super.start();
    client = WebClient.create(vertx);

    Router router = Router.router(vertx);
    router.get("/").handler(this::invokeMyFirstMicroservice);

    vertx.createHttpServer()
      .requestHandler(router)
      .rxListen(8081).subscribe(
      httpServer -> System.out.println("Client is Running @ " + httpServer.actualPort()),
      error -> System.out.println(error)
    );
  }

  private void invokeMyFirstMicroservice(RoutingContext rc) {

    HttpRequest<JsonObject> request1 = client
      .get(8082, "localhost", "/Srisha")
      .as(BodyCodec.jsonObject());

    HttpRequest<JsonObject> request2 = client
      .get(8082, "localhost", "/Subramanian")
      .as(BodyCodec.jsonObject());

    Single<HttpResponse<JsonObject>> s1 = request1.rxSend();
    Single<HttpResponse<JsonObject>> s2 = request2.rxSend();

    Single.zip(s1, s2, (apiOne, apiTwo) -> {
      // We have the result of both request in Luke and Leia
      return new JsonObject()
        .put("firstName", apiOne.body().getString("message"))
        .put("lastName", apiTwo.body().getString("message"));
    }).subscribe(
      x -> {
        rc.response().end(x.encode());
      },
      t -> {
        rc.response().end(new JsonObject().encodePrettily());
      });
  }

}

class HelloMicroservice extends AbstractVerticle {
  @Override
  public void start() {
    Router router = Router.router(vertx);
    router.get("/").handler(this::hello);
    router.get("/:name").handler(this::hello);
    vertx.createHttpServer()
      .requestHandler(router)
      .rxListen(8082).subscribe(server -> {
      System.out.println("Provider is listening in " + server.actualPort());
    });
  }

  private void hello(RoutingContext rc) {
    String message = "hello";
    if (rc.pathParam("name") != null) {
      message += " " + rc.pathParam("name");
    }
    JsonObject json = new JsonObject().put("message", message);
    rc.response()
      .putHeader(HttpHeaders.CONTENT_TYPE, "application/json")
      .end(json.encode());
  }

}

public class WebClientReactiveMicroService extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebClientReactiveMicroService.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.rxDeployVerticle(new HelloMicroservice())
      .subscribe(r -> System.out.println("HelloMicroservice deployed"));
    vertx.rxDeployVerticle(new HelloConsumerMicroservice())
      .subscribe(r -> System.out.println("HelloConsumerMicroservice deployed"));
  }
}















